<!DOCTYPE html>
<html lang="en">
<head>
    <title>Conveyor Monitoring</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #232323;
            color: lightgray;
        }

        #left-panel {
            background-color: black;
            width: 200px;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            padding: 20px;
            border-right: 3px solid;
            border-color: black;
        }

        #view-container {
            margin-left: 245px;
            height: 100%;
            padding: 10px;
        }

        #emulator-container {
            height: 200px;
            border-bottom: 1px solid;
            border-color: white;
        }

        #emulator {
            width: 100%;
            height: 100%;
        }

        #canvas-container {
            height: calc(100% - 200px);
            padding-top: 10px;
        }

        #conveyor {
            width: calc(100% - 10px);
            height: calc(100% - 10px);
        }

        #execute {
            background-color: white;
            color: black;
            padding: 0.7rem;
            border-radius: 0.7rem;
            font-weight: bold;
            font-size: 14px;
        }

        .control {
            margin-bottom: 20px;

            select {
                width: 100%;
            }
        }

        .arrow {
            stroke: white;
            fill: none;
        }

        .logo {
            background-color: black;
            font-family: Roboto, sans-serif;
            font-weight: bold;
            font-size: 18px;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            padding: 1rem;
            justify-content: center;
            height: fit-content;
        }

        .logo1 {
            padding-right: 0.3em;
        }

        .logo2 {
            /*background-color: orange;*/
            background-color: white;
            color: black;
            padding: 0.7rem;
            border-radius: 0.7rem;
        }
    </style>
</head>
<body>
<div id="left-panel">
    <div>
        <div class="logo">
            <p class="logo1">conveyor</p>
            <p class="logo2">monitoring</p>
        </div>
    </div>
    <h1 id="status"></h1>
    <div id="controls" style="display: none">
        <h2>Controls</h2>
        <div class="control">
            <label for="station_select">Station <span id="station_count"></span></label><select
                id="station_select"></select>
        </div>
        <div class="control">
            <label for="command_select">Command</label><select id="command_select"></select>
        </div>
        <div class="control">
            <button id="execute" onclick="executeCommand()" disabled="disabled">Execute</button>
        </div>
        <div class="control" id="devices_block" style="display: none">
            <br>
            <hr>
            <br>
            <span>Devices <span id="devices_count">(0)</span>:</span>
            <br>
            <span id="devices_body"></span>
        </div>
        <div class="control" id="devices_lost_block" style="display: none">
            <hr>
            <br>
            <span>Lost devices <span id="devices_lost_count">(0)</span>:</span>
            <br>
            <span id="devices_lost"></span>
        </div>
        <div class="control" id="devices_failed_to_take_block" style="display: none">
            <hr>
            <br>
            <span>Failed to take devices <span id="devices_failed_to_take_count">(0)</span>:</span>
            <br>
            <span id="devices_failed_to_take"></span>
        </div>
        <div class="control" id="devices_commands_block" style="display: none">
            <hr>
            <br>
            <span id="commands_title" style="display: none">Active commands:</span>
            <br>
            <span id="commands_body"></span>
        </div>
    </div>
</div>

<div id="view-container">
    <div id="emulator-container" style="display: none">
        <svg id="emulator"></svg>
    </div>
    <div id="canvas-container">
        <svg id="conveyor"></svg>
    </div>
</div>

<script>
    // const websocket_url = 'localhost:18765';
    const websocket_url = getGistContentSync('https://gist.githubusercontent.com/vadgus/735c3b1220d4559c7679701ffeba309f/raw/296919a06d0b90ba337cbd9543da84d1609ccd28/monitoring_pl0.txt');

    const websocket_emulator_url = 'localhost:18789'
    const ws_reconnect_time_milliseconds = 1000

    const svg = d3.select("#conveyor");
    const stationRadius = 100;
    const padding = stationRadius;
    const paddingSpace = padding * 3 / 2 + stationRadius;
    const rowSpacing = 10; // Increased spacing between stations in the same group

    let width = null;
    let height = null;
    let max_group = 0;
    triggerResize();

    let ws = null;
    let ws_emulator = null;
    let stations = [];
    let devices = {};
    let command_list = [];

    function getGistContentSync(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false); // false makes the request synchronous
        xhr.send(null);

        if (xhr.status === 200) {
            return xhr.responseText.trim(); // Returns the response text, trimmed
        } else {
            console.error('Error fetching the Gist:', xhr.statusText);
            return null;
        }
    }

    function connect() {
        ws = new WebSocket('ws://' + websocket_url);

        ws.onopen = function () {
            console.log('Connected to monitoring WebSocket server ' + websocket_url);
        };

        ws.onmessage = function (event) {
            const data = JSON.parse(event.data);
            updateVisualization(data);
            triggerResize();
        };

        ws.onclose = function () {
            updateVisualization();
            ws = null;
            setTimeout(connect, ws_reconnect_time_milliseconds);
        };

        ws.onerror = function () {
            ws.close();
        };
    }

    function connect_emulator() {
        ws_emulator = new WebSocket('ws://' + websocket_emulator_url);

        ws_emulator.onopen = function () {
            console.log('Connected to emulator WebSocket server ' + websocket_emulator_url);
        };

        ws_emulator.onmessage = function (event) {
            const data = JSON.parse(event.data);
            updateEmulation(data);
        };

        ws_emulator.onclose = function () {
            updateEmulation();
            ws_emulator = null;
            setTimeout(connect_emulator, ws_reconnect_time_milliseconds);  // todo comment after finish
        };

        ws_emulator.onerror = function () {
            ws_emulator.close();
        };
    }

    function updateStationsSelectOptions(groupedStations) {
        const selectElement = document.getElementById('station_select');

        selectElement.innerHTML = '';

        const option = document.createElement('option');
        option.value = '';
        option.text = '';
        selectElement.appendChild(option);

        document.getElementById('execute').disabled = !groupedStations.size || !command_list.length;

        groupedStations.forEach((groupStations) => {
            groupStations.forEach((station) => {
                const option = document.createElement('option');
                option.value = station.station_id;
                option.text = station.station_name;
                selectElement.appendChild(option);
            });
        });
    }

    function updateCommandSelectOptions(commands) {
        if (commands.sort().join(',') === command_list.sort().join(',')) {
            return;
        }

        const selectElement = document.getElementById('command_select');

        selectElement.innerHTML = '';

        const option = document.createElement('option');
        option.value = '';
        option.text = '';
        selectElement.appendChild(option);

        // Separate commands into two groups
        const commandsSystem = commands.filter(command => command.startsWith('system_')).sort();
        const commandsStation = commands.filter(command => !command.startsWith('system_')).sort();

        // Create optgroup for commands without underscore
        const optGroupWithoutUnderscore = document.createElement('optgroup');
        optGroupWithoutUnderscore.label = 'Station';
        commandsStation.forEach((command) => {
            const option = document.createElement('option');
            option.value = command;
            option.text = command.charAt(0).toUpperCase() + command.slice(1);
            optGroupWithoutUnderscore.appendChild(option);
        });

        // Create optgroup for commands with underscore
        const optGroupWithUnderscore = document.createElement('optgroup');
        optGroupWithUnderscore.label = 'System';
        commandsSystem.forEach((command) => {
            const option = document.createElement('option');
            option.value = command;
            option.text = command.charAt('system_'.length).toUpperCase() + command.slice('system_'.length + 1);
            optGroupWithUnderscore.appendChild(option);
        });

        // Append both opt groups to the select element
        selectElement.appendChild(optGroupWithoutUnderscore);
        selectElement.appendChild(optGroupWithUnderscore);
    }

    function areStationIdsSame(oldStationIds, newStationIds) {
        if (oldStationIds.length !== newStationIds.length) {
            return false;
        }

        const oldStationIdsSet = new Set(oldStationIds);
        for (let newStationId of newStationIds) {
            if (!oldStationIdsSet.has(newStationId)) {
                return false;
            }
        }

        return true;
    }

    function formatDevices(data, groupedStations) {
        let str = "";

        groupedStations.forEach((groupStations) => {
            groupStations.forEach((station) => {
                Object.keys(data.devices).forEach(deviceId => {
                    if (
                        station.station_id === data.devices[deviceId].station_id
                        && !(station.station_id in Object.keys(data.devices_failed_to_take))
                    ) {
                        str += `\n${deviceId}: ${station.station_name}`;
                    }
                });
            });
        });

        return str;
    }

    function formatBytes(bytes) {
        if (bytes === 0) return '0B';
        const k = 1024;
        const sizes = ['B', 'K', 'M', 'G', 'T'];
        let i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + sizes[i];
    }

    function formatLostDevices(data) {
        let str = "";
        data.devices_lost.forEach(deviceId => {
            const device = data.devices[deviceId];
            if (device) {
                str += `\n${device.device_id}: ${device.station_id.slice(0, 7)} ${device.station_state}`;
            } else {
                str += `\n${device.device_id}`;
            }
        });
        return str;
    }

    function formatFailedToTakeDevices(data) {
        let str = "";

        Object.keys(data.devices_failed_to_take).forEach(deviceId => {
            str += `\n${data.devices_failed_to_take[deviceId].device_id}: `;
            str += data.devices_failed_to_take[deviceId].station_id.slice(0, 7);
            str += ` (${getRelativeTime(data.devices_failed_to_take[deviceId].time_utc)})`;
        });

        return str;
    }

    function getRelativeTime(utcTimestamp) {
        const timestampInMs = utcTimestamp * 1000;
        const now = Date.now();
        const elapsed = now - timestampInMs;

        const seconds = Math.floor(elapsed / 1000) % 60;
        const minutes = Math.floor(elapsed / 60000) % 60;
        const hours = Math.floor(elapsed / 3600000) % 24;
        const days = Math.floor(elapsed / 86400000);

        if (days > 0) {
            return `${days}d ${hours}h ${minutes}m ${seconds}s ago`;
        } else if (hours > 0) {
            return `${hours}h ${minutes}m ${seconds}s ago`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds}s ago`;
        } else {
            return `${seconds}s ago`;
        }
    }

    function updateEmulation(data = null) {
        if (data === null) {
            document.getElementById('emulator-container').setAttribute('style', 'display: none');
            return null;
        }
        document.getElementById('emulator-container').setAttribute('style', '');

        const svg = d3.select("#emulator");
        const containerHeight = 200;
        const paddingBottom = 50;
        const stationHeight = containerHeight - paddingBottom;
        const deviceHeight = stationHeight - 25;

        svg.style("display", "");

        // Clear previous drawings
        svg.selectAll("*").remove();

        // Extract and scale the conveyor length
        const conveyorLength = data.conveyor.conveyor_length_mm;
        const conveyorSpeed = data.conveyor.conveyor_speed_mm_s;
        const svgWidth = svg.node().getBoundingClientRect().width;
        const scaleX = d3.scaleLinear()
            .domain([0, conveyorLength])
            .range([0, svgWidth]);

        // Draw stations
        const stations = Object.entries(data.stations);
        stations.forEach(([stationId, stationData]) => {
            const x = scaleX(stationData.offset_mm);

            // Draw station line
            svg.append("line")
                .attr("x1", x)
                .attr("y1", stationHeight - 60)
                .attr("x2", x)
                .attr("y2", 35)
                .attr("stroke", "white")
                .attr("stroke-width", 1);

            // Draw station name
            svg.append("text")
                .attr("x", x)
                .attr("y", 20)
                .attr("stroke", "white")
                .attr("text-anchor", "middle")
                .text(stationId + " [" + stationData.offset_mm + "]");

            // Draw horizontal arm area line
            const armAreaStart = scaleX(stationData.offset_mm - stationData.arm_area_mm / 2);
            const armAreaEnd = scaleX(stationData.offset_mm + stationData.arm_area_mm / 2);

            svg.append("line")
                .attr("x1", armAreaStart)
                .attr("y1", stationHeight - 60)
                .attr("x2", armAreaEnd)
                .attr("y2", stationHeight - 60)
                .attr("stroke", "white")
                .attr("stroke-width", 1);
        });

        // Draw devices
        const devices = Object.entries(data.devices);
        devices.forEach(([deviceId, devicePosition]) => {
            const x = scaleX(devicePosition);

            // Draw device
            svg.append("circle")
                .attr("cx", x)
                .attr("cy", deviceHeight + 17)
                .attr("r", 5)
                .attr("fill", "white");

            // Draw device id
            svg.append("text")
                .attr("x", x)
                .attr("y", deviceHeight + 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "white")
                .text(deviceId);

            // // Draw device position
            // svg.append("text")
            //     .attr("x", x)
            //     .attr("y", deviceHeight + 35)
            //     .attr("text-anchor", "middle")
            //     .attr("font-size", "10px")
            //     .attr("fill", "white")
            //     .text(devicePosition);
        });

        // Draw 0 on the left bottom corner
        svg.append("text")
            .attr("x", 0)
            .attr("y", containerHeight - 5)
            .attr("text-anchor", "start")
            .attr("font-size", "10px")
            .attr("fill", "white")
            .text("0");

        // Draw conveyor length on the right bottom corner
        svg.append("text")
            .attr("x", svgWidth)
            .attr("y", containerHeight - 5)
            .attr("text-anchor", "end")
            .attr("font-size", "10px")
            .attr("fill", "white")
            .text(conveyorLength);

        // Draw numbers at intervals of conveyor_speed_mm_s
        for (let i = conveyorSpeed; i < conveyorLength; i += conveyorSpeed) {
            const x = scaleX(i);

            svg.append("text")
                .attr("x", x)
                .attr("y", containerHeight - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "white")
                .text(i);
        }
    }

    function updateVisualization(data = null) {
        if (!data) {
            data = {
                'commands': {},
                'command_list': [],
                'stations': {},
                'devices': {},
                'devices_lost': [],
                'devices_failed_to_take': {},
            }
            document.getElementById('status').innerText = 'Disconnected from ' + websocket_url;
            document.getElementById('controls').setAttribute('style', 'display: none');
            document.getElementById('station_count').setAttribute('style', 'display: none');
        } else {
            document.getElementById('status').innerText = '';
            document.getElementById('controls').setAttribute('style', '');
            document.getElementById('station_count').innerText = `(${Object.keys(data.stations).length})`;
            document.getElementById('station_count').setAttribute('style', '');
        }

        const groupedStations = d3.group(Object.values(data.stations), d => d.station_group);
        max_group = d3.max(Object.values(data.stations), d => d.station_group);
        const maxStationsInGroup = d3.max([...groupedStations.values()], g => g.length);
        const rowHeight = (height - padding * 2) / maxStationsInGroup;
        const oldStationIds = [];

        Object.values(stations).forEach(station => {
            oldStationIds.push(station.id);
        });

        if (Object.keys(data.devices).length - data.devices_lost.length - Object.keys(data.devices_failed_to_take).length > 0) {
            document.getElementById('devices_body').innerText = formatDevices(data, new Map(
                Array.from(groupedStations.entries()).sort((a, b) => a[0] - b[0])
            ));
            document.getElementById('devices_count').innerText = `(${Object.keys(data.devices).length - data.devices_lost.length - Object.keys(data.devices_failed_to_take).length})`
            document.getElementById('devices_block').setAttribute('style', '');
        } else {
            document.getElementById('devices_block').setAttribute('style', 'display: none');
            document.getElementById('devices_body').innerText = '';
        }

        if (data.devices_lost.length) {
            document.getElementById('devices_lost').innerText = formatLostDevices(data);
            document.getElementById('devices_lost_count').innerText = `(${data.devices_lost.length})`
            document.getElementById('devices_lost_block').setAttribute('style', '');
        } else {
            document.getElementById('devices_lost_block').setAttribute('style', 'display: none');
            document.getElementById('devices_lost').innerText = '';
        }

        if (Object.keys(data.devices_failed_to_take).length) {
            document.getElementById('devices_failed_to_take').innerText = formatFailedToTakeDevices(data);
            document.getElementById('devices_failed_to_take_count').innerText = `(${Object.keys(data.devices_failed_to_take).length})`
            document.getElementById('devices_failed_to_take_block').setAttribute('style', '');
        } else {
            document.getElementById('devices_failed_to_take_block').setAttribute('style', 'display: none');
            document.getElementById('devices_failed_to_take').innerText = '';
        }

        stations = [];
        groupedStations.forEach((groupStations, group) => {
            groupStations.forEach((d, i) => {
                stations.push({
                    library_version: d.library_version,
                    id: d.station_id,
                    station_name: d.station_name,
                    device_id: d.device_id,
                    device_marker_size: d.device_marker_size,
                    station_state: d.station_state,
                    station_group: d.station_group,
                    command: d.command,
                    command_executed: d.command_executed,
                    count_devices_in_work: d.count_devices_in_work,
                    station_error_data: d.station_error_data,
                    memory_worker_used_bytes: d.memory_worker_used_bytes,
                    memory_system_total_bytes: d.memory_system_total_bytes,
                    x: group * paddingSpace + padding,
                    y: i * (rowHeight + rowSpacing) + padding
                });
            });
        });

        updateCommandSelectOptions(data.command_list);
        command_list = data.command_list

        if (!areStationIdsSame(oldStationIds, Object.keys(data.stations))) {
            updateStationsSelectOptions(new Map(
                Array.from(groupedStations.entries()).sort((a, b) => a[0] - b[0])
            ));
        }

        devices = data.devices;

        const stationGroups = svg.selectAll(".station-group").data(stations, d => d.id);
        const enterGroups = stationGroups.enter().append("g").attr("class", "station-group");
        enterGroups.append("rect")
            .attr("class", "station")
            .attr("width", stationRadius * 2)
            .attr("height", stationRadius * 2)
            .attr("fill-opacity", 0.7)
            .attr("rx", 5)
            .attr("ry", 5);

        enterGroups.append("text").attr("class", "station-label id");
        enterGroups.append("text").attr("class", "station-label station_state");
        enterGroups.append("text").attr("class", "station-label command");
        enterGroups.append("text").attr("class", "station-label count_devices_in_work");
        enterGroups.append("text").attr("class", "station-label station_error_data");
        enterGroups.append("text").attr("class", "station-label memory_system_total_bytes");
        enterGroups.append("text").attr("class", "station-label library_version");
        enterGroups.append("text").attr("class", "station-label library_version_line");

        enterGroups.merge(stationGroups)
            .select("rect")
            .attr("x", d => d.x - stationRadius)
            .attr("y", d => d.y - stationRadius)
            .attr("fill", d => {
                switch (d.station_state) {
                    case 'paused':
                        return 'orange';
                    case 'terminated':
                    case 'stopped':
                        return '#ad42f5';
                    case 'error':
                        return 'red';
                    case 'init':
                    case 'work':
                        return 'lightblue';
                    case 'reject':
                        return 'pink';
                    case 'release':
                    case 'take':
                        return 'green';
                    default:
                        return 'yellow';
                }
            });

        enterGroups.merge(stationGroups)
            .select("text.library_version")
            .attr("x", d => d.x)
            .attr("y", d => d.y - 87)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(d => d.library_version);

        enterGroups.merge(stationGroups)
            .select("text.library_version_line")
            .attr("x", d => d.x)
            .attr("y", d => d.y - 80)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(function () {
                return "________________________"
            });

        enterGroups.merge(stationGroups)
            .select("text.station_error_data")
            .attr("x", d => d.x)
            .attr("y", d => d.y - 54)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(function (d) {
                if (!d.station_error_data) {
                    return ""
                }
                return d.station_error_data
            });

        enterGroups.merge(stationGroups)
            .select("text.memory_system_total_bytes")
            .attr("x", d => d.x)
            .attr("y", d => d.y - 36)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(function (d) {
                if (d.memory_worker_used_bytes !== null) {
                    // can be used
                    // let percent = Math.round(100 * d.memory_worker_used_bytes / d.memory_system_total_bytes)
                    // if (percent > 0) {
                    //     percent = ` ${percent}%`
                    // } else {
                    //     percent = ""
                    // }
                    return `${formatBytes(d.memory_worker_used_bytes)} [${formatBytes(d.memory_system_total_bytes)}]`
                } else {
                    return `[${formatBytes(d.memory_system_total_bytes)}]`
                }
            });

        enterGroups.merge(stationGroups)
            .select("text.id")
            .attr("x", d => d.x)
            .attr("y", d => d.y - 18)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(d => d.station_name);

        enterGroups.merge(stationGroups)
            .select("text.station_state")
            .attr("x", d => d.x)
            .attr("y", d => d.y)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(d => d.station_state);

        enterGroups.merge(stationGroups)
            .select("text.command")
            .attr("x", d => d.x)
            .attr("y", d => d.y + 18)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(function (d) {
                if (!d.command) {
                    return ""
                }
                if (d.command_executed !== true) {
                    return `*${d.command}*`
                } else {
                    return d.command
                }
            });

        enterGroups.merge(stationGroups)
            .select("text.count_devices_in_work")
            .attr("x", d => d.x)
            .attr("y", d => d.y + 36)
            .attr("text-anchor", "middle") // Center the text horizontally
            .attr("dy", "0.35em") // Adjust the text vertically to center it better
            .text(d => d.count_devices_in_work);

        stationGroups.exit().remove();

        drawConnections();
    }

    function drawConnections() {
        // Remove old lines
        svg.selectAll(".arrow").remove();
        svg.selectAll(".device-label").remove();

        const connections = stations.flatMap(fromStation => {
            const fromDevice = devices[fromStation.device_id];
            if (!fromDevice) return [];

            // Find stations in the next group
            const nextGroupStations = stations.filter(toStation =>
                toStation.station_group === fromStation.station_group + 1 &&
                toStation.device_id === fromDevice.device_id
            );

            return nextGroupStations.map(toStation => {
                const isThinLine = !(fromStation.station_state === 'release' && toStation.station_state === 'take');
                let deviceMarkerSizeText = ""
                if (fromStation.device_marker_size) {
                    deviceMarkerSizeText = ` [${fromStation.device_marker_size}]`
                }
                return {
                    from: fromStation,
                    to: toStation,
                    device_id: fromStation.device_id,
                    color: 'white',
                    strokeWidth: isThinLine ? 1 : 2,
                    displayText: isThinLine ? `*${fromStation.device_id}${deviceMarkerSizeText}*` : `${fromStation.device_id}${deviceMarkerSizeText}`
                };
            });
        });

        svg.selectAll(".arrow")
            .data(connections)
            .enter()
            .append("line")
            .attr("class", "arrow")
            .attr("x1", d => d.from.x)
            .attr("y1", d => d.from.y)
            .attr("x2", d => d.to.x)
            .attr("y2", d => d.to.y)
            .attr("stroke", d => d.color)
            .attr("stroke-width", d => d.strokeWidth)
            .attr("marker-end", "url(#arrowhead)");

        svg.selectAll(".device-label")
            .data(connections)
            .enter()
            .append("text")
            .attr("class", "device-label")
            .attr("x", d => (d.from.x + d.to.x) / 2)
            .attr("y", d => (d.from.y + d.to.y) / 2 - 15)
            .attr("text-anchor", "middle")
            .attr("fill", "white")
            .text(d => d.displayText);
    }

    function executeCommand() {
        const stationSelect = document.getElementById('station_select');
        const commandSelect = document.getElementById('command_select');

        const station_id = stationSelect.options[stationSelect.selectedIndex].value;
        const station_command = commandSelect.options[commandSelect.selectedIndex].value;
        if (station_id && station_command) {
            if (station_command.startsWith('system_')) {
                if (!confirm('Are you sure?')) {
                    return;
                }
            }

            const commandObject = {
                'station_id': station_id,
                'station_command': station_command,
            }
            ws.send(JSON.stringify(commandObject));
        }
    }

    function triggerUpdate() {
        drawConnections();
    }

    function triggerResize() {
        width = (max_group + 1) * paddingSpace + padding;
        height = window.innerHeight;
        document.getElementById('view-container').setAttribute('style', 'min-width: ' + width + 'px');
    }

    window.triggerUpdate = triggerUpdate;
    window.addEventListener("resize", triggerResize);

    svg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .attr("fill", "white")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5");

    connect();
    // connect_emulator();
</script>
</body>
</html>
